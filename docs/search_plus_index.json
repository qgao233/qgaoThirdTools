{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/":{"url":"chapter1/","title":"1 git篇","keywords":"","body":"动画学习git：https://learngitbranching.js.org/?locale=zh_CN Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"1 git 命令","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 概念 2 基础 3 版本回退 3.1 reset 3.2 revert 3.2.1 两种commit 3.2.2 revert两种commit 3.3 checkout 3.4 测试reset和checkout reset和checkout的区别 3.5 restore 4 rm 5 分支 5.1 查看分支创建时间 5.2 stash 5.3 checkout切换分支 6 远程 6.1 连接远程库 6.2 关联本地分支与远程分支 7 冲突 8 标签 9 删除仓库 10 总结 git命令 1 概念 工作区：work区 暂存区：staged区 仓库区：history区 2 基础 git init 创建本地仓库 git add 添加某文件到暂存区 git add -A 它能stages所有文件，包括删除文件的操作 git add . 只能stages新文件和被修改文件，没有被删除文件 git commit 将暂存区所有文件提交到当前分支（快照） git status 查看工作区状态 git diff 查看工作区某文件的变化 git log 查看提交到分支的版本/commit id（commit的记录） git log --graph --pretty=oneline --abbrev-commit 可以查看到合并的图（merge） git reflog 查看git所有分支操作（历史记录操作，每一个操作对应着一个ID） 3 版本回退 3.1 reset git reset 版本回退（unlink...?需要将编辑器关闭） git reset --hard HEAD^ 其中HEAD为当前版本，一个^为上一版本，两个^为上上一个版本，往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 除了用HEAD这种方式，还可以用commitID（可以通过git log查看） git reset --mixed： 此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和add信息 git reset --soft： 回退到某个版本，只回退了commit的信息。如果还要提交，直接commit即可 git reset --hard： 彻底回退到某个版本，本地的源码也会变为上一个版本的内容，慎用！ git reset --hard cb926...（一个SHA1计算出来的一个非常大的数字，用十六进制表示），可以回退到这个“提交版本” git reset HEAD 文件名 可以把暂存区的修改撤销掉（unstage），重新放回工作区 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示当前分支最新的版本 head指向分支名或提交记录（提交的hash值），即head->[branch]->[hash提交记录] 可以使用git checkout [hash提交记录] 更改head的指向 原来指向的提交记录就跟从来没有提交过一样。 在reset后， C2 所做的变更还在，但是处于未加入暂存区状态(unstage)。可以想像成同时移动了head指针和分支名main的指针到C1，但不同的是，reset会把C2更改过的放进unstage，而如果移动指针的话，工作区不会有什么改变。 3.2 revert 为了撤销更改并分享给别人，需要使用 git revert: 可以撤销指定的提交内容，撤销后会生成一个新的commit。 新提交记录 C2' 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。 revert 之后就可以把你的更改推送到远程仓库与别人分享啦。 3.2.1 两种commit Git 之 revert 常规的 commit：git commit 提交的 commitgit show 3e853bd commit 3e853bdcb2d8ce45be87d4f902c0ff6ad00f240a merge commit：git merge 合并两个分支之后，得到一个新的 merge commit merge commit 包含两个 parent commit，代表该 merge commit 是从哪两个 commit 合并过来的。 git show bd86846 commit bd868465569400a6b9408050643e5949e8f2b8f5 Merge: ba25a9d 1c7036f 3.2.2 revert两种commit revert 常规commit：使用 git revert [commit id] 即可，git 会生成一个新的 commit，将指定的 commit 内容从当前分支上撤除。 revert merge commit： git 只能撤销合并分支中的其中一条分支，如果直接使用 git revert [merge commit id]，git将不知道到底要撤除哪一条分支上的内容修改， 这时需要添加 -m 选项：表示这次 revert 的是一个 merge commit。 并且需要指定一个 parent number的分支，标识出主线， 主线的内容修改将会保留， 而另一条分支的内容修改将被 revert。 即完整的命令应该是：git revert -m [parent number] [merge commit id] parent number：是一个数字，数字取值为 1 和 2，对应git show从左到右排列出来的分支。 以上一小节的merge commit为例，此时想要撤销该merge commit： 分析：parent commit 分别为 ba25a9d 和 1c7036f，要保留ba25a9d分支的修改，而抛弃1c7036f这个分支的修改，应这样写： git revert -m 1 bd86846 3.3 checkout 有切换分支和撤销修改两种意思，当后面跟的是分支名，就表示切换，后面跟的是路径就是撤销，如果撤销文件名和分支名相同，需要在其前面加上“-- ”注意有一个空格。所以一般为了好分辨，如果是路径就加上“-- ”，如果是切换分支就不加。 这里讲撤销： git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到工作区没有修改的状态（用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”） Git 的一些命令中，借鉴了这种用法。使用 -- 去隔离开“树”与“路径”。 例如，你想还原 一个文件 path/to/file.txt，在Git中使用如下命令 git checkout path/to/file.txt 但是天杀的居然有一个文件名字就叫做 \"master\" 如果你套用上面的命令，想还原“master”文件 git checkout master 最终起的效果是变成切换到了master分支上。 正确的做法是使用 --，这样它后面的字符串不会当做“树”，而认为是文件路径。 如git checkout -- master git checkout 还有一种作用，如果工作区中的文件被误删，但如果本地仓库中还有，可以将仓库中的文件恢复到工作区，即可以从本地仓库中有而工作区没有的copy到工作区中。 3.4 测试reset和checkout 首先，对于两者来说， 是否指定历史版本， 指定了历史版本，如命令加上了head，则基于head指向的历史版本对工作区进行处理 不指定历史版本，如命令没加head，则默认基于head指向的历史版本对工作区进行处理 对于reset： 是否指定文件，无需--符号， 指定则只对指定的文件进行处理 否则对所有的文件进行处理 对于checkout： 是否指定文件， 有--符号，则只对指定的文件进行处理 无--符号，则切换分支或移动head指针 创建如下环境， 创建a,b两文件，分别写入1，提交历史版本\"1st\" 更改a,b两文件，改为2，提交历史版本\"2nd\" 此时head指向\"2nd\". 修改a为3，add进staged区，再次修改a为4, 回退到1st: 输入git reset head^ --soft 此时查看a为4，b为2，各区状态如下： 其实staged区里的a为2，b为2，而工作区的a为4，b为2， 也就是说\"2nd\"历史版本里a,b的修改放到了staged区 reset和checkout的区别 reset: 回退，根据head指针指向的版本 git reset --soft:中间夹着的历史版本中的修改全都变成可commit的状态 git reset --mixed:默认，即不加--mixed的情况下，中间夹着的历史版本中的修改全都变成可add的状态 git reset --hard:work区、staged区、history区全回到指定版本刚被commit后的状态 如现在有1、2(*head)两个历史版本，此时工作区修改为12，然后add了，又在工作区修改13， 即工作区也有修改(13)，staged区也有修改(12)， 当只使用git reset时，默认是回退到head指向的历史版本(2)，由于现在当前版本没有历史版本，所有就不回退，只把staged区的修改回退到可add，但由于此时工作区的内容在之前add后又修改成了13，这时回退的12，无法覆盖工作区，因此在reset后工作区仍为13. 当只使用git reset head^时，回退到head指向的历史版本(1),其中夹了一个历史版本(2)，那么(2)的历史版本记录的修改会变为可add放进工作区，一样的，若是工作区的更新时间比回退版本的新，那么回退的无法覆盖工作区。 checkout: 恢复，优先级(staged->history) 首先判断staged区是否有修改，有则将work区的修改恢复成staged区一样，结束，没有跳第2步； 根据head指针指向的history区版本，将work区的修改恢复成history区一样，结束。 如a为1，add后，这时修改a为2，使用git checkout -- a可以让a恢复成staged区里的值，即1. 如果staged区没有修改，就会将head指向的历史版本的a覆盖此时工作区中的a的值。 3.5 restore git restore --stage 和git restore 两个命令，总结如下， 1、文件在暂存区且工作区未作修改的情况 使用git restore --staged 把文件从暂存区移动到工作区，即文件不被追踪； 2、文件在暂存区且工作区又修改过的情况 使用git restore --staged 把文件从暂存区移动到工作区，且不会撤销修改的内容； 同git reset 使用git restore 文件仍在暂存区且会撤销文件修改的内容； 同git checkout 3、文件在本地代码库且工作区又修改过的情况 使用git add 把文件重新放到暂存区，且保留文件的修改； 使用git restore 文件仍在本地代码库且会撤销文件的修改； 同git checkout 4 rm git rm 删除本地连同版本库里的某文件，且需要commit一次 git rm –cached a/2.txt //unstaged,将暂存区的文件放回工作区 git rm -r --cached a/2.txt 删除a目录下的2.txt文件(删除远程不删除本地) git rm -r --cached a 删除a目录，目录名有空格命令行需要用\"\\\"进行转义，（如git rm -r --cached Photo\\ albums） 5 分支 git branch name 创建分支name，创建了分支后如果在工作区修改后且并未add、commit，如果这时想切换到其他分支，请务必stash，否则在当前的修改会覆盖你想切换的分支中的相关文件。 如果在dev分支工作区做了修改，且没有add或stash，这时你checkout到foo分支，就会把在dev分支做出的修改移动到foo分支，dev分支工作区就没有修改，而foo分支做出了修改 ``` git branch 查看本地所有分支 git branch -d dev 删除dev分支，如果未合并，不允许删除 git branch -D 强行删除，即使未合并 ``` git merge dev 把dev分支合并到当前分支 fast-forward，查看log无法查到合并记录 git merge --no-ff 禁用fast-forward(快进模式)表示普通合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。其实合并相当于提交当前分支，可以加上-m参数 git merge --no-ff -m \"merge with no-ff\" dev 5.1 查看分支创建时间 git reflog show --date=iso 可以查看到指定分支的历次更改记录，最下面一条的时间即是分支创建时间。 5.2 stash git stash 将当前分支的工作现场储藏起来 类似栈，先进后出 git stash list 查看当前分支所储藏的工作现场列表 git stash apply 将当前分支储藏的工作现场列表最新的放回工作区，stash列表的其记录并不删除 git stash pop 同上一样，只不过列表中的其记录会被删除 git stash apply stash@{0} 放回指定的stash记录，需要手动删除stash列表记录 git stash drop stash@{0} 删除stash列表中的指定记录，用法和上述相同，如果不跟名称，删除所有 git checkout -b branch-name origin/branch-name 本地没有某分支，在本地创建和远程分支对应的分支，使用这个，本地和远程分支的名称最好一致 5.3 checkout切换分支 git checkout 当它是切换分支意义的时候，实质上是移动的HEAD指针。 当选择切换分支时，git checkout dev，此时head指向dev指向的提交记录 git branch -f main HEAD~3 将main分支指向head的父结点的父结点的父结点 git checkout -b dev 创建dev分支，并切换到dev分支 6 远程 ssh-keygen -t rsa -C \"邮箱\" 生成密钥，如果远程仓库没有保存你生成的密钥，你将只能pull，而不能push 在这之前要确保git config --global –list，若没有配置用户名和电子邮件地址 git config --global user.name \"这里换上你的用户名\" git config --global user.email \"这里换上你的邮箱\" 每次commit时都会引用这两条信息，以说明是谁提交了代码。 6.1 连接远程库 git remote add origin git@gitee.com:ber3ud4/learngit.git（首先本地仓库已经建立好了） git remote -v 查看已连接的远程库，如果没有推送权限，就看不到push的地址。 git remote set-url origin git@gitee.com:ber3ud4/learngit.git 更改remote链接 git branch -M main //修改当前分支名为main（因为说以前的master有黑人奴隶歧视啥的） git push -u origin master origin代表远程仓库，将本地的当前分支推送到远程库的master分支，-u表示同时把本地的master分支和远程同名的master分支关联起来，在以后的推送或者拉取时就可以简化命令，第一次push必须要加-u，否则会报错，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上（在之前，首先要add,commit到本地仓库中） 或者git push --set-upstream origin branch1 关联远程branch1分支和当前本地分支 6.2 关联本地分支与远程分支 如果远程新建了一个分支，本地没有该分支。 可以利用 git checkout --track origin/branch_name ，这时本地会新建一个分支名叫 branch_name ，会自动跟踪远程的同名分支 branch_name。 git checkout --track origin/branch_name 如果本地新建了一个分支 branch_name，但是在远程没有。 这时候 push 和 pull 指令就无法确定该跟踪谁，一般来说我们都会使其跟踪远程同名分支，所以可以利用 git push --set-upstream origin branch_name ，这样就可以自动在远程创建一个 branch_name 分支，然后本地分支会 track 该分支。后面再对该分支使用 push 和 pull 就自动同步。 git push --set-upstream origin branch_name 7 冲突 https://www.cnblogs.com/gavincoder/p/9071959.html 只有分支合并会产生冲突 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程仓库的分支和你的本地分支相偏离了，需要先用git pull试图合并； 如果合并有冲突（merging提示），则找到冲突的地方（git会在文件中将互相冲突的内容标明），视情况更改，更改完成后在本地提交，至此冲突解决完毕（将不会再有merging提示）； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 8 标签 git tag \\ 用于新建一个标签，默认为HEAD，也可以指定一个commit id git tag v0.9 6224937 git show \\ 查看标签信息 git tag -d v0.1 删除v0.1这个标签 git push origin \\ 推送某个标签到远程 git push origin --tags 一次性推送全部尚未推送到远程的本地标签 git tag -d v0.9 git push origin :refs/tags/v0.9 标签已经推送到远程，先从本地删除，然后，从远程删除。删除命令也是push 同一台电脑设置多个公钥与不同GITHUB帐号交互，在config文件中只需要更改host即可，git remote add git@host:账户名/仓库名.git，其中的host用config中的host 9 删除仓库 删除本地仓库 方法： 1.手动删除掉“Git本地仓库”里面的根目录下面的隐藏文件夹“.git” 2.命令：find . -name \".git\" | xargs rm -Rf 验证：在Gitbash中进入仓库的目录中，如果目录末尾没有\"(master)\"，说明成功删除了本地仓库。 删除远程仓库 在github网站上找到tab上的settings,然后找到删除仓库链接即可。 10 总结 说白了，git的提交记录就是一颗颗结点组成的树， 每一颗结点就是一次提交记录， HEAD就是可以在树上结点移动的指针， 分支名也是可以在树上结点移动的指针，只是默认指向该条分支下最新的提交记录。 git仓库分为3个区， 工作区（看得到的文件系统） 暂存区stage 历史区history（里面存的链表或者说是树【因为有多个分支】）：每1个结点便为commit的版本。 其实可以类比【事务】。 只有当一次事务commit后，才真正地保存了修改，每一次事务当然有事务id，git中对应commit的唯一hash，而history区中head指针则指向某一次提交的版本，默认指向最新修改的版本。 git status查看work dir和stage区域的状态， git log查看history区域的提交历史。 git checkout 会覆盖 git reset的应用场景（将文件的状态从stage退化到工作区，和checkout不同）： 对某文件进行了修改，然后git add将修改信息同步进了stage【工作区和stage区的内容相同，history不同】 此时使用git reset,会将history区里head指向的对应文件对stage区里的该文件进行覆盖【工作区为做出修改后的内容，history同化stage区的内容】,并将该文件设为unstage状态【此时可以接着之前的修改继续对该文件进行修改，然后git add】 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"2 git 远程","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 git pull 1.1 pull完整格式 1.2 省略本地分支名 1.3 当前分支与远程分支存在多追踪关系 1.4 当前分支只有一个追踪关系 1.5 拉取远程主机上被他人rebase操作然后强制推送的分支 1.6 在本地删除远程主机上已删除的对应分支 1.7 pull注意事项 2 git push 2.1 push命令的完整格式 2.2 省略远程分支名 2.3 省略本地分支名 2.4 当前分支与远程分支存在多追踪关系 2.5 push注意事项之历史偏离 git 远程 Git：远程分支----git pull和git push命令用法介绍 1 git pull git branch -r 查看远程分支 远程分支 origin/** 是本地的分支，与远程仓库中的分支一一对应，只有当远程仓库中的分支发生了变化，通过fetch才能修改本地中远程分支的指向。 git pull 就是 git fetch 和 git merge 的缩写！ git init git remote add origin git@github.com-qinzhu:614756773/huoguo.git (git remote set-url origin 更改后的链接) pull需要当前分支与远程分支有联系才行。 pull远程的所有分支，直接使用git pull，后不加参数。 1.1 pull完整格式 取回远程主机的指定分支，再与本地的指定分支合并。 git pull : ：origin 1.2 省略本地分支名 取回远程主机的指定分支，再与本地的当前分支合并。 git pull ：远程分支名 1.3 当前分支与远程分支存在多追踪关系 取回远程主机与当前分支有追踪关系的分支，再与本地的当前分支合并。 git pull 1.4 当前分支只有一个追踪关系 git pull 1.5 拉取远程主机上被他人rebase操作然后强制推送的分支 有人推送了经过rebase操作的提交，并丢弃了你的本地开发所基于的一些提交，但是你push之后，那些被对方丢弃的提交又出现了，这是对方所不希望看到的。 所以在拉取合并时加上 --rebase 选项，git内部会自动检测，合并的结果会丢弃一些提交，符合预期。 git pull --rebase : 1.6 在本地删除远程主机上已删除的对应分支 git pull -p 1.7 pull注意事项 git pull这个命令，我们经常会用，它默认是使用merge方式将远端别人的修改拉到本地； 如果带上上参数git pull -r，就会使用rebase的方式将远端修改拉到本地。 这二者最直观的区别就是：merge方式合并的分支会有很多「分叉」，而rebase方式合并的分支就是一条直线。 对于多人协作，merge方式并不好，多分支画面肯定杂乱，杂乱就意味着很容易出问题，所以一般来说，实际工作中更推荐使用rebase方式合并代码。 我站在dev分支，使用git rebase master，把dev接到master分支之上。Git 是这么做的： 首先，找到这两条分支的最近公共祖先LCA，然后从master节点开始，重演LCA到dev几个commit的修改，如果这些修改和LCA到master的commit有冲突，就会提示你手动解决冲突，最后的结果就是把dev的分支完全接到master上面。 2 git push git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，在项目中进行推送之前，最好检查一下这个配置。 当push成功时，远程仓库的分支会更新，本地仓库中的远程分支origin/*也会更新。 2.1 push命令的完整格式 git push : 2.2 省略远程分支名 git push ：本地分支名 将本地的指定分支推送到远程主机的同名分支上。注意如果远程主机不存在该同名分支，则会自动新建同名分支。 通常加上-u，将远程分支与本地分支关联起来。 2.3 省略本地分支名 表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支 git push : //Git v1.7.0 之后 git push --delete 2.4 当前分支与远程分支存在多追踪关系 将本地的当前分支推送到远程主机有追踪关系的对应分支上。 git push 2.5 push注意事项之历史偏离 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。 这种情况下,历史偏离有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。 即先pull再push。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"3 .gitignore","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 使用 .gitignore 作为白名单 例子 调试 .gitignore .gitignore 文件失效 1. 只在缓存区 2. 已经 commit 提交了，但是还没有 push 到远程 3. 已经推送到远程 .gitignore 使用 .gitignore 作为白名单 .gitignore 的常规用法很简单——给它一个文件名或匹配的通配符，该文件将被阻止。但是，当您将其用作白名单时，它会变得有点复杂。 首先，您需要文件顶部的以下两个指令，默认情况下，它们会使用无所不包的通配符*阻止所有内容： * !*/ 第二行是必要的，因为白名单不像阻塞那么简单。由于 Git 处理这些文件的方式，如果它看到某个目录被阻止，它甚至不会 尝试检查该目录中的任何内容，以查看它以后是否被解除阻止。它只是跳过它并忽略该目录中的所有规则。 所以，这里的第二行告诉 Git 专门检查子文件夹。感叹号! 用于将规则变成白名单。它匹配所有目录，但由于它不匹配这些目录中的任何内容，因此 Git 不会仅使用这两行来跟踪任何文件。 例子 * !*/ # track this file !.gitignore # whitelist everything in ./config/ !config/ 该.gitignore 文件本身在主目录中，因此可以正常将其列入白名单。将目录列入白名单只需要一个尾部斜杠，Git 将在该目录中恢复正常，覆盖之前的全阻塞通配符。 如果要明确地将目录及其所有内容列入白名单，则必须使用双通配符 !config/**. 单个通配符不会递归地传播到子目录中。这将覆盖所有其他阻止规则。 调试 .gitignore 如果您的配置有问题，您可以使用check-ignoreGit 命令进行调试： git check-ignore -v testfile.json .gitignore 文件失效 检查 .gitignore 文件是否是对应目录的仓库的忽略文件。 检查规则是否写错。 如果上面两个点都没有问题，但是就是不生效，是什么原因？ 答案是，当远程仓库或者缓存区（本地仓库的历史版本区）已经存在被忽略文件的情况下，这个时候相应的忽略规则是不起作用的。 解决办法： 1. 只在缓存区 文件较少时： git rm --cached 文件较多时： git rm -r --cached . git add . git commit -m 'XXXX' 2. 已经 commit 提交了，但是还没有 push 到远程 这种情况下，我们需要使用撤销 commit 操作了， git reset //这个命令, 把 commit 历史撤销，对应缓存区内容也撤销，工作区内容不变 git add . git commit -m 'XXXX' 3. 已经推送到远程 本地部分的，对应上面两种情况操作，远程仓库的，只能手动删除对应的文件了。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section4/":{"url":"chapter1/section4/","title":"4 git commit提交类型规范","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 统一格式 2 type 3 scope 4 #issue 5 举例 git commit提交类型规范 https://blog.csdn.net/qq_41999617/article/details/110581321 1 统一格式 git commit -m 'type(scope): 描述(#issue)' 规范有3点: type scope issue 2 type type desc init 初始化 feat 新特性 fix 修改问题 refactor 代码重构 docs 文档修改 style 代码格式修改, 注意不是 css 修改 test 测试用例修改 build 构建项目 chore 其他修改, 比如依赖管理 scope commit 影响的范围, 比如route, component, utils, build... subject commit 的概述 3 scope 可以为提交类型添加一个围在圆括号内的作用域，以为其提供额外的上下文信息； 4 #issue 就是issues的编号。 5 举例 issue如下： 解决issue后,进行提交： git commit -m \"fix(helloWorld):修改字段名(#1)\" 查看github仓库： Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section5/":{"url":"chapter1/section5/","title":"5 github的contribution显示问题","keywords":"","body":"github的contribution显示问题 ssh-keygen -t rsa -C \"邮箱\" 这里生成密钥时指定的邮箱其实无所谓是什么，只是起作标识的作用。 但是，本地git config所设置的user.name和user.email则只有两者和远程仓库github上登录的一样，github上的账号的仓库才能显示contribution. git config示例 git config user.name \"这里换上你的用户名\" git config user.email \"这里换上你的邮箱\" git config有几个类型： git config --system：存放在/etc/gitconfig，针对整个系统生效的，几乎不会使用 git config --global：存放在~/.gitconfig，这个是针对用户的，对系统中这个用户的所有项目都生效，很常用 git config --local：存放在在项目的.git/config，这是针对某个项目设置用户名和邮箱的（也是不加选项时默认的选项） 还有其它选项，可输入git config查看。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section6/":{"url":"chapter1/section6/","title":"6 成为别人项目的贡献者","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Fork 别人的仓库 2 修改代码 3 提交贡献 4 成为别人项目的贡献者 成为别人项目的贡献者 一篇文章教会你拉取别人的GitHub代码，修改后提交成为贡献者！！！ 注意，只是贡献者，不会在contribution显示。 例：我觉得别人的项目有个bug需要修复，或者我觉得可以更新个好玩的东西到别人项目里去，该怎么做呢？ 1 Fork 别人的仓库 点击 fork 就可以把这个仓库加载到自己的 GitHub上，相当于复制了一份别人的仓库。 2 修改代码 直接在github上进行修改 或者clone到本地修改后再push到github 3 提交贡献 进入别人的github仓库的pull requests标签，并点击new pull request。 一般会自动跳出compare & pull request 这里说白了就是提出合并分支的请求：表示想将自己仓库里某分支的commits合并(接)到别人仓库的某分支上 compare确认后，直接点击create pull request 4 成为别人项目的贡献者 原作者进入他的github仓库，同意我的分支合并请求后，我就成为贡献者啦。 可以在contributors处看见我的头像。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter1/section7/":{"url":"chapter1/section7/","title":"7 修改本地仓库和远程仓库的名字","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 修改远程仓库的名字 2 修改本地仓库的名字 修改本地仓库和远程仓库的名字 1 修改远程仓库的名字 在github上找到settings，直接rename 2 修改本地仓库的名字 直接重命名本地仓库所在的目录的名字。 然后，重新关联远程仓库与本地仓库。 git remote rm origin git remote add origin git@github.com:qgao233/qgaoFinancialPortfolio.git git push -u origin master Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "},"chapter2/":{"url":"chapter2/","title":"2 gitbook篇","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 word文档转markdown 2 gitbook客户端 3 使用gitbook 3.1 初始化 3.2 转成网页 3.3 插件 4 bug 4.1 Error: ENOENT: no such file or directory, stat (…) 【version 3.2.3】 4.2 子目录中的md文件内目录格式失效 4.3 Template render error … expected variable end 4.4 gitbook一个进程要占用（至少）两个端口，35729、4000。 5 更多同类型工具 gitBook篇 1 word文档转markdown writage 插件，下载地址http://www.writage.com/#download 下载安装完成后，重新打开word，保存原word文档为markdown类型即可 2 gitbook客户端 前提：得安装nodejs，我选的官网的绿色版 安装客户端：npm install gitbook-cli –g gitbook v2.3.2有一个bug： D:\\work\\node-v16.15.1-win-x64\\node_modules\\gitbook-cli\\node_modules\\npm\\node_modules\\graceful-fs\\polyfills.js 这个文件的statFix函数调用需要被注释，否则会报cb.apply is not a function： //fs.stat = statFix(fs.stat) //fs.fstat = statFix(fs.fstat) //fs.lstat = statFix(fs.lstat) 3 使用gitbook 3.1 初始化 进入要存储的位置初始化gitbook: gitbook init 出现两个文件，README.md是说明文档，SUMMARY.md是书的章节目录 SUMMARY.md的初始化内容： # Summary * [Introduction](README.md) 指定端口：gitbook serve --port 2333 生成pdf格式：gitbook pdf ./ ./mybook.pdf 3.2 转成网页 gitbook serve：该命令后会在书籍的文件夹中生成一个 _book 文件夹, 里面的内容即为生成的 html文件，并开启服务器（http://localhost:4000） gitbook build：该命令生成网页而不开启服务器 3.3 插件 在gitbook init的目录下新建book.json，然后往里填入 { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\", \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"tbfed-pagefooter\", \"page-treeview\", \"popup\", \"expandable-chapters\", \"-sharing\", \"sharing-plus\", \"page-toc-button\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy qgao 2021-*\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-treeview\": { \"copyright\": \"Copyright &#169; qgao 2021-*\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"qq\": true, \"twitter\": true, \"weibo\": true }, \"page-toc-button\": { \"maxTocDepth\": 4, \"minTocSize\": 2 } } } 再通过gitbook install安装 4 bug 4.1 Error: ENOENT: no such file or directory, stat (…) 【version 3.2.3】 用户目录下找到以下文件。 .gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js 把所有的confirm: true替换为confirm: false 4.2 子目录中的md文件内目录格式失效 不要把目录写在文件第1行，第1行无法起效 4.3 Template render error … expected variable end 连在一起的两个大括号如 {{2}} 会把括号里的2当做一个模板变量。如果这个变量不存在，会报错 Template render error: expected variable end。详细的解释看下面： https://wwshen.gitbooks.io/omooc2py/0MOOC/dakuohao.html https://www.weihuayi.cn/tools/gitbook.html https://juejin.im/post/5ce51e126fb9a07ed440d7d0#heading-22 解决方式 把连续的大括号{{替换为中间加个空格{ {，把}}替换为} }。 4.4 gitbook一个进程要占用（至少）两个端口，35729、4000。 同主机启动多个gitbook实例，需要port、lrport各不占用、各不相同。 gitbook serve --port=4001 --lrport=4101 5 更多同类型工具 docsify 看云文档 ... Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:27:24 "},"chapter3/section1/":{"url":"chapter3/section1/","title":"1 Maven生命周期和插件的详细介绍","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Maven自定义属性 2 Maven生命周期 2.1 clean生命周期 2.2 default生命周期 2.3 site生命周期 3 mvn命令和生命周期 4 Maven插件 4.1 插件目标 4.2 插件前缀 4.3 插件和生命周期阶段绑定 4.4 maven内置插件以及绑定 5 POM.xml插件配置详解 5.1 插件目标共享参数配置 5.2 插件目标参数配置 5.3 插件解析机制 Maven生命周期和插件的详细介绍 https://baijiahao.baidu.com/s?id=1714329632775162386&wfr=spider&for=pc 1 Maven自定义属性 pom.xml中的，properties 是 project 元素的子元素，用户可以在properties 中自定义一些用户属性，然后可以在其他地方使用 ${属性名称} 这种方式进行引用。 2 Maven生命周期 我们开发一个项目的时候，通常有这些环节：创建项目、编写代码、清理已编译的代码、编译代码、执行单元测试、打包、集成测试、验证、部署、生成站点等，这些环节组成了项目的生命周期，这些过程也叫项目的构建过程。 maven将项目的生命周期抽象成了3套生命周期，每套生命周期又包含多个阶段，每套中具体包含哪些阶段是maven已经约定好的，但是每个阶段具体需要做什么，是用户可以自己指定的。 maven中定义的3套生命周期： clean生命周期 default生命周期 site生命周期 这3套生命周期是相互独立的，没有依赖关系的，而每套生命周期中有多个阶段，每套中的多个阶段是有先后顺序的，并且后面的阶段依赖于前面的阶段，而用户可以直接使用 mvn 命令来调用这些阶段去完成项目生命周期中具体的操作，命令是：mvn 生命周期阶段。 2.1 clean生命周期 clean生命周期的目的是清理项目，它包含3个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 我们可以通过 mvn pre-clean 来调用clean生命周期中的 pre-clean 阶段需要执行的操作。调用 mvn post-clean 会执行上面3个阶段所有的操作，每个生命周期中的后面的阶段会依赖于前面的阶段，当执行某个阶段的时候，会先执行其前面的阶段。 2.2 default生命周期 default生命周期是maven主要的生命周期，主要被用于构建应用，包含了23个阶段： validate 校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。 initialize 初始化：初始化构建状态，比如设置属性值。 generate-sources 生成源代码：生成包含在编译阶段中的任何源代码。 process-sources 处理源代码：处理源代码，比如说，过滤任意值。 generate-resources 生成资源文件：生成将会包含在项目包中的资源文件。 process-resources 编译：复制和处理资源到目标目录，为打包阶段最好准备。 compile 处理类文件：编译项目的源代码。 process-classes 处理类文件：处理编译生成的文件，比如说对Java class文件做字节码改善优化。 generate-test-sources 生成测试源代码：生成包含在编译阶段中的任何测试源代码。 process-test-sources 处理测试源代码：处理测试源代码，比如说，过滤任意值。 generate-test-resources 生成测试源文件：为测试创建资源文件。 process-test-resources 处理测试源文件：复制和处理测试资源到目标目录。 test-compile 编译测试源码：编译测试源代码到测试目标目录. process-test-classes 处理测试类文件：处理测试源码编译生成的文件。 test 测试：使用合适的单元测试框架运行测试（Juint是其中之一）。 prepare-package 准备打包：在实际打包之前，执行任何的必要的操作为打包做准备。 package 打包：将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 pre-integration-test 集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。 integration-test 集成测试：处理和部署项目到可以运行集成测试环境中。 post-integration-test集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。 verify 验证：运行任意的检查来验证项目包有效且达到质量标准。 install 安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。 deploy 部署：将最终的项目包复制到远程仓库中与其他开发者和项目共享。 2.3 site生命周期 site生命周期的目的是建立和发布项目站点，Maven能够基于pom.xml所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。主要包含以下4个阶段： pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上。 3 mvn命令和生命周期 从命令行执行maven任务的最主要方式就是调用maven生命周期的阶段，需要注意的是，每套生命周期是相互独立的，但是每套生命周期中阶段是有前后依赖关系的，执行某个的时候，会按序先执行其前面所有的阶段。 mvn执行阶段的命令格式是：mvn 阶段1 [阶段2] [阶段n] mvn clean:调用clean生命周期的clean阶段，实际执行的阶段为clean生命周期中的pre-clean和clean阶段。 mvn test :调用default生命周期的test阶段，实际上会从default生命周期的第一个阶段（ validate ）开始执行一直到 test 阶段结束。 mvn clean install ：执行了两个阶段： clean 和 install ，clean 位于 clean 生命周期中， install 位于 default 生命周期中，所以这个命令会先从 clean 生命周期中的 pre-clean 阶段开始执行一直到 clean 生命周期的 clean 阶段；然后会继续从default 生命周期的 validate 阶段开始执行一直到default生命周期的 install 阶段。 mvn clean deploy：先按顺序执行 clean 生命周期的 [pre-clean,clean] 这个闭区间内所有的阶段，然后按序执行 default 生命周期的 [validate,deploy] 这个闭区间内的所有阶段（也就是default 生命周期中的所有阶段）。这个命令内部包含了清理上次构建的结果、编译代码、运行单元测试、打包、将打好的包安装到本地仓库、将打好的包发布到私服仓库。 4 Maven插件 maven插件主要是为maven中生命周期中的阶段服务的，maven中只是定义了3套生命周期，以及每套生命周期中有哪些阶段，具体每个阶段中执行什么操作，完全是交给插件去干。 插件可以通过 mvn 命令的方式调用直接运行，或者将插件和maven生命周期的阶段进行绑定，然后通过 mvn 阶段 的方式执行阶段的时候，会自动执行和这些阶段绑定的插件。 4.1 插件目标 maven中的插件以jar的方式存在于仓库中，通过坐标进行访问，每个插件中可能为了代码可以重用，一个插件可能包含了多个功能。插件中的每个功能就叫做插件的目标（Plugin Goal），每个插件中可能包含一个或者多个插件目标（Plugin Goal）。 1、目标参数 插件目标是用来执行任务的，那么执行任务肯定是有参数配的，这些就是目标的参数，每个插件目标对应于java中的一个类(插件的类)，参数就对应于这个插件类中的属性。 2、列出插件所有目标： mvn 插件goupId:插件artifactId[:插件version]:help mvn 插件前缀:help 3、查看插件目标参数列表 mvn 插件goupId:插件artifactId[:插件version]:help -Dgoal=目标名称 -Ddetail mvn 插件前缀:help -Dgoal=目标名称 -Ddetail 4、命令行运行插件 mvn 插件goupId:插件artifactId[:插件version]:插件目标 [-D目标参数1] [-D目标参数2] [-D目标参数n] mvn 插件前缀:插件目标 [-D目标参数1] [-D目标参数2] [-D目标参数n] 5、插件传参 可以通过 -D 后面跟用户属性的方式给用户传参，还可以在pom.xml中 properties 的用户自定义属性中进行配置：如true。 6、获取插件目标详细描述信息 mvn help:describe -Dplugin=插件goupId:插件artifactId[:插件version] -Dgoal=目标名称 -Ddetail mvn help:describe -Dplugin=插件前缀 -Dgoal=目标名称 -Ddetail 这个命令调用的是help插件的 describe 这个目标，这个目标可以列出其他指定插件目标的详细信息。也可以试试其他插件目标的详细信息。 4.2 插件前缀 运行插件的时候，可以通过指定插件坐标的方式运行。maven中给插件定义了一些简捷的插件前缀，可以通过插件前缀来运行指定的插件。 可以通过下面命令查看到插件的前缀： mvn help:describe -Dplugin=插件goupId:插件artifactId[:插件version] 4.3 插件和生命周期阶段绑定 将生命周期中的阶段和插件的目标进行绑定的时候，执行 mvn 阶段 就可以执行和这些阶段绑定的 插件目标 。 4.4 maven内置插件以及绑定 1、maven内置绑定 clean maven-clean-plugin:clean process-resources maven-resources-plugin:resources 复制主资源文件至主输出目录 compile maven-compiler-plugin:compile 编译主代码至主输出目录 process-test-resources maven-resources-plugin:testResources 复制测试资源文件至测试输出目录。 test-compile maven-compiler-plugin:testCompile 编译测试代码至测试输出目录 test maven-surefile-plugin:test 执行测试用例 package maven-jar-plugin:jar 创建项目jar包 install maven-install-plugin:install 将输出构件安装到本地仓库 deploy maven-deploy-plugin:deploy 将输出的构件部署到远程仓库 site maven-site-plugin:site site-deploy maven-site-plugin:deploy 2、自定义绑定 举例：创建项目的源码jar包，将其安装到仓库中 插件 maven-source-plugin 的 jar-no-fork 可以帮助我们完成该任务，我们将这个目标绑定在default 生命周期的 verify 阶段上面。在pom.xml中配置如下： org.apache.maven.plugins maven-source-plugin 3.2.0 attach-source jar-no-fork verify 运行命令：mvn install 5 POM.xml插件配置详解 5.1 插件目标共享参数配置 build->plugins->plugin 中配置： 参数值 configuration 节点下配置目标参数的值，节点名称为目标的参数名称，上面这种配置对当前插件的所有目标起效，也就是说这个插件中所有的目标共享此参数配置。 5.2 插件目标参数配置 project->build->plugins->plugin->executions->execution 元素中进行配置，如下： 参数值 这种配置常用于自定义插件绑定，只对当前任务有效。 更多maven插件的帮助文档可以参考maven的官方网站，上面有详细的介绍，建议大家去看看。 5.3 插件解析机制 插件仓库配置 插件构件也是基于坐标存储在maven仓库中。插件仓库是在pluginRepositories->pluginRepository 元素中配置的，如下： myplugin-repository http://repo1.maven.org/maven2/ true 插件的默认groupId，在pom.xml中配置插件的时候，如果是官方的插件，可以省略 groupId 。如maven-compiler-plugin ，这个插件是编译代码的，是maven官方提供的插件，我们可以省略了groupId。如下： maven-compiler-plugin 3.1 1.8 1.8 1.8 插件前缀的解析 使用mvn命令调用插件的时候，可以使用插件的前缀来代替繁琐的插件坐标的方式。 插件前缀与插件groupId:artifactId是一一对应的关系，这个关系的配置存储在仓库的元数据中，元数据位于下面2个xml中： ~/.m2/repository/org/apache/maven/plugins/maven-metadata-central.xml ~/.m2/repository/org/codehaus/mojo/maven-metadata-central.xml Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-06-07 18:18:36 "}}