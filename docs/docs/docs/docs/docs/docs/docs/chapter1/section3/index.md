# .gitignore

## 使用 .gitignore 作为白名单

`.gitignore` 的常规用法很简单——给它一个文件名或匹配的通配符，该文件将被阻止。但是，当您将其用作白名单时，它会变得有点复杂。

首先，您需要文件顶部的以下两个指令，默认情况下，它们会使用无所不包的通配符`*`阻止所有内容：
```
*
!*/
```

第二行是必要的，因为白名单不像阻塞那么简单。由于 Git 处理这些文件的方式，如果它看到某个目录被阻止，它甚至不会 尝试检查该目录中的任何内容，以查看它以后是否被解除阻止。它只是跳过它并忽略该目录中的所有规则。

所以，这里的第二行告诉 Git 专门检查子文件夹。感叹号! 用于将规则变成白名单。它匹配所有目录，但由于它不匹配这些目录中的任何内容，因此 Git 不会仅使用这两行来跟踪任何文件。

### 例子
```
*
!*/

# track this file
!.gitignore

# whitelist everything in ./config/
!config/
```

该.gitignore 文件本身在主目录中，因此可以正常将其列入白名单。将目录列入白名单只需要一个尾部斜杠，Git 将在该目录中恢复正常，覆盖之前的全阻塞通配符。

如果要**明确地将目录及其所有内容**列入白名单，则必须使用双通配符 `!config/**`. 单个通配符不会递归地传播到子目录中。这将覆盖所有其他阻止规则。

### 调试 .gitignore

如果您的配置有问题，您可以使用check-ignoreGit 命令进行调试：

`git check-ignore -v testfile.json`

## .gitignore 文件失效

1. 检查 .gitignore 文件是否是对应目录的仓库的忽略文件。
2. 检查规则是否写错。

如果上面两个点都没有问题，但是就是不生效，是什么原因？

答案是，当**远程仓库**或者**缓存区**（本地仓库的历史版本区）已经存在被忽略文件的情况下，这个时候相应的忽略规则是不起作用的。

解决办法：

### 1. 只在缓存区
文件较少时：
```
git rm --cached <filename>
```

文件较多时：
```
git rm -r --cached .
git add .
git commit -m 'XXXX'
```

### 2. 已经 commit 提交了，但是还没有 push 到远程
这种情况下，我们需要使用撤销 commit 操作了，
```
git reset <commit_id> //这个命令, 把 commit 历史撤销，对应缓存区内容也撤销，工作区内容不变
git add .
git commit -m 'XXXX'
```

### 3. 已经推送到远程
本地部分的，对应上面两种情况操作，远程仓库的，只能手动删除对应的文件了。